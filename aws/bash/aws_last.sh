#!/bin/bash
#
# aws_last.sh                                    10/18/2017 21:15:00
#
# Copyright (c) 2017, NVIDIA CORPORATION.  All rights reserved.
#
# Example bash test script to show how to restart a AWS instance that is in
# either a stopped or running state. Since the IP address of the instance 
# changes when it's restarted, this code all works from the InstanceID, 
# querying the instance for it's IP address every time it is called.
#
# Instance ID was saved in a little file in the path specified by OPT_FILE
# below. It was written when the instance was first generated by the script
# aws_create_instance, and looks like 
#
#    INSTANCE_ID=i-0a8b2ead21ee921a5
#    NAME_TAG_INSTANCE="peter Wed 19:45 test instance"
#    STOP_ON_SSH_EXIT=ask
#    TERMINATE_ON_SSH_EXIT=ask
#    KEY_FILE=/home/peter/.ssh/baseos-awskey-oregon.pem
#    LOGIN_NAME=ubuntu
#    SSH_SECURITY_GROUP_NAME="peter Example Volta SSH Security Group"
#    SSH_SECURITY_GROUP_CREATED_ID=sg_1233455
#    SECURITY_GROUP_DELETE_IF_CREATED="true"
#
# Usage:  aws_last [options]
#   state                    shows current state
#   stop                     stops instance if running
#   terminate                terminates instance if running
#   sshcmd                   displays ssh command needed
#   [null]                   starts if not running, ssh into it when ready
# 
# When you exit, it will obey the STOP_ON flags, that were part of config
# state when it was originally created.
#
# This only handles the state of one instance. 
#

OPT_DIR=/tmp/awsami                        # directory to hold persistent files
OPT_FILE=$OPT_DIR/state                    # name of file

##############################################################################
# useful functions
#

# ask (returnval, question, prompt, default, [timeout])
#
# case insensitive y/n or yes/no question prompter
# args: 1:returnval 2:question 3:y/n prompt string, 4:default return. 5:optional timeout in secs
#
# returns: "yes" or "no"
# usage: ask answer "Do you like cupcakes?" "(y/N) : " "yes"   # no timeout
ask() {
    local __result=$1
    echo -n "$2" " "            # -n is a bash extension not to write newline, not in sh
    if [ -z $5 ]; then          # prompt and read users response, no timeout
        read -p "$3" CONFIRM;
    else                        # $4 is the timeout in sections or fractions
        read -t $5 -p "$3" CONFIRM;
        ret=$?
        if [ $ret -gt 0 ]; then
            echo "timeout"      # send newline if timeout
            ANSWER=$4           # default
        fi
    fi
    shopt -u nocasematch        # restore back to default casematch
    case "$CONFIRM" in          # case insensitive matching, different froms of yes and no
        "y"   ) ANSWER="yes" ;;
        "yes" ) ANSWER="yes" ;;
        "n"   ) ANSWER="no" ;;
        "no"  ) ANSWER="no" ;;
        *     ) ANSWER=$4 ;;    # default answer, should be "yes" or "no"
    esac
    shopt -u nocasematch        # restore back to default casematch
    eval $__result=$ANSWER      # pass back answer - "yes" or "no"
}
# CheckPrerequisites 
#
# Verifies that necessary prerequsist features are avalable on the machine
# In this case, aws of the proper version and the jq utility to parse JSON
# 
CheckPrerequisites() {
    ERROR=0
    AWS_V1=1            # required aws version number
    AWS_V2=11
    AWS_V3=164

       # check that aws is installed, and it's version

    command -v "aws" > /dev/null
    if [ $? -ne 0 ]; then
        ERROR=1
        echo "ERROR: missing application \"aws\" require to interface with AWS cloud. Please download" >&2
    else
            # aws --version
            # aws-cli/1.11.164 Python/3.5.2 Linux/4.4.0-93-generic botocore/1.7.22
            # .164 provides ways to update tag fields, required   (10/2017 -ish)

        VERINFO=$( aws --version 2>&1 )    # get both stdout and stderr, different version do differntly
        VER=$(echo $VERINFO | cut -d' ' -f 1 | cut -d'/' -f 2)     # just the 1.11.164
        V1=$(echo $VER | cut -d'.' -f 1)
        V2=$(echo $VER | cut -d'.' -f 2)
        V3=$(echo $VER | cut -d'.' -f 3)
        if [ $V1 -lt $AWS_V1 ] || [ $V2 -lt $AWS_V2 ] || [ $V3 -lt $AWS_V3 ]; then
            ERROR=1
            echo "ERROR: installed \"aws\" version is $VER, need at least $AWS_V1.$AWS_V2.$AWS_V3. Please upgrade" >&2
        fi
    fi

        # aws output config format needs to be "json", can "text" or "table". If set wrong
        # all the expected json format output here won't work. Default if not set is "json"
        # see: From http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html

    AWS_CFG_FILENAME=~/.aws/config        # no qoutes, ~ won't be expanded from "~/.aws/.." 
    if [ -e "$AWS_CFG_FILENAME" ]; then

             # expecting a line like "output = json"

        OUTPUT_MODE=$(cat "$AWS_CFG_FILENAME" | grep "output" | cut -d'=' -f 2 | sed 's/ *//g')
        if [ "$OUTPUT_MODE" != "json" ] && [ "$OUTPUT_MODE" != "" ]; then
            echo "ERROR: aws output mode is must be \"json\" for this script to work. run \"aws configure\" to set"
            ERROR=1
        fi
    fi

        # verify that .pem key specified in cfg files exist

    if ! [ -e "$KEY_FILE" ]; then
        echo "ERROR: did not find key file \"$KEY_FILE\""
        ERROR=1
    fi

        # check for jq json parsing application

    command -v "jq" > /dev/null
    if [ $? -ne 0 ]; then
        ERROR=1

        echo "ERROR: missing application \"jq\", used to parse JSON output. Please download" >&2
    fi
        # and errors? if so, exit 
    if [ $ERROR != 0 ]; then
        exit 1
    fi
}

# SourceStateFile
#
# reads in the file that contains the state of the instance that was created
#
# See comments in main file header for format of this file
# 
SourceStateFile() {
    if [ -e $OPT_FILE ]; then
        source $OPT_FILE
    else
        echo "could not find $OPT_FILE"
        exit 1
    fi
}
# GetInstanceState
# 
# Gets current state of the instance. Puts it in "STATE" global
#
# Exits if we don't can't get the state. 
#
GetInstanceState() {
    if [ "$INSTANCE_ID" == "" ]; then       # "" would show all instances, not what we want
        exit 1
    fi
    DESCRIBE_INSTANCE_JSON=$(aws ec2 describe-instances --instance-id $INSTANCE_ID)
    RC=$?
    if [ $RC != 0 ]; then
        exit $RC             # not able to get any info on instance
    fi
    STATE=$(echo $DESCRIBE_INSTANCE_JSON | jq .Reservations[0].Instances[0].State.Name | sed 's/\"//g')
    if [ "$STATE" == "" ] || [ "$STATE" == "null" ]; then
        echo "Can't obtain info on $INSTANCE_ID $NAME_TAG_INSTANCE. Destroyed?"
    fi 
}
# StartRunningIfNeeded
#
# Checks the state of the instance, and starts it if it is stopped, or 
# exits if it's restartable. If it's running, this function simply 
# returns.  NOTE: 'running' here means that AWS has created the VM
# and has started it. It doesn't mean that linux is up an we can ssh into it
#
StartRunningIfNeeded() {
    case "$STATE" in
        "stopped")          # stopped, can be restarted
            echo "starting $INSTANCE_ID $NAME_TAG_INSTANCE"
            START_INSTANCE_JSON=$(aws ec2 start-instances --instance-ids $INSTANCE_ID)
            ;;
        "running")          # currently running
            ;;
        "pending" | "shutting-down" | "stopping" )
            echo "The instance $INSTANCE_ID $NAME_TAG_INSTANCE is currently $STATE. Try again later"
            exit 1
            ;;
        "terminated" )      # compleatly gone, just the dust is left
            echo "The instance $INSTANCE_ID $NAME_TAG_INSTANCE was terminated"
             ;;
        *)
            echo "Can't obtain info on $INSTANCE_ID $NAME_TAG_INSTANCE. Destroyed?"
            exit 1
            ;;
    esac
}

# WaitForRunning
#
# Wait till the state of the instance is in "running". At this point
# we have valid IP and volume info in the instance describe structures
#
WaitForRunning() {
    MAX_ATTEMPTS=40
    for (( ATTEMPT=0; ATTEMPT<$MAX_ATTEMPTS; ATTEMPT++)); do
        DESCRIBE_INSTANCE_STATUS_JSON=$(aws ec2 describe-instance-status --instance-id $INSTANCE_ID)
        STATE=$(echo $DESCRIBE_INSTANCE_STATUS_JSON | jq .InstanceStatuses[0].InstanceState.Name | sed 's/\"//g')
        if [ "$STATE" == "running" ]; then
            break;
        fi
        echo -ne "$ATTEMPT $INSTANCE_ID $STATE\r"
        sleep 1
    done
    if [ "$STATE" != "running" ]; then
        echo "Timeout, did not enter \"running\" state       " >&2
        exit 1
    fi
}

# GetInstanceIP
#
# Pull the public IP out of the instance data
#
GetInstanceIP() {
    DESCRIBE_INSTANCE_JSON=$(aws ec2 describe-instances --instance-id $INSTANCE_ID)
    PUBLIC_ID=$(echo $DESCRIBE_INSTANCE_JSON | jq .Reservations[0].Instances[0].PublicDnsName | sed 's/\"//g' )
    if [ "$PUBLIC_ID" == "" ] || [ "$PUBLIC_ID" == "null" ]; then
        echo "ERROR: no IP address found" >&2
        exit 1
    fi
    return 0
}

# WaitForPing 
#
# Try pinging the instance till it responds. (linux network is up)
#
# It is  going to take up to 5 minutes or so to allow the instance to finish 
# booting till we can ssh into it. -- first step, wait till we can ping 
# (meaning that the network portion of the kernel is up and reponding)
# NOTICE: The SecurityGroup we used  must enable Pings for this to work!
WaitForPing() {
    local MAX_ATTEMPTS=300
    local ATTEMPT

    for (( ATTEMPT=0; ATTEMPT<$MAX_ATTEMPTS; ATTEMPT++)); do
        ping -c 1 -W 1 $PUBLIC_ID &> /dev/null
        if [ $? -eq 0 ]; then
            break;                # we can ping
        fi
        echo -ne "$ATTEMPT ping $PUBLIC_ID    \r"
        sleep 1
    done
    if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
        echo "Timeout waiting for ping to $PUBLIC_ID"
        exit 1
    fi
    return 0
}
# WaitForSSH
#
# Wait till we can ssh into the instance. Can take time if large # gpus/memory
#
# Next step is to wait till we can SSH into the instance. If this is first
# boot of a NVIDIA GPU instance, it may take a bit more time for it to go
# from being ping-able to when it can ssh, due to the fact that the drivers
# have to be linked and loaded that first boot time.
WaitForSSH() {
    local MAX_ATTEMPTS=300
    local ATTEMPT
    local STR RC

    for (( ATTEMPT=0; ATTEMPT<$MAX_ATTEMPTS; ATTEMPT++)); do
        STR=$(ssh -oStrictHostKeyChecking=no -i $KEY_FILE $LOGIN_NAME@$PUBLIC_ID "uptime" 2> /dev/null)
        RC=$?
        if [ $RC -eq  0 ]; then    # no error
            break
        fi
        echo -ne "$ATTEMPT ssh $PUBLIC_ID    \r"
        sleep 1
    done
    if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
        echo "Timeout waiting for SSH to $PUBLIC_ID"
        exit 1
    fi
    return 0
}

# DoSSH
#
# Enter into SSH in the session
DoSSH() {

    echo ""
    echo "Entering $NAME_TAG_INSTANCE"
    echo ""
    echo "ssh -i $KEY_FILE $LOGIN_NAME@$PUBLIC_ID"
    ssh -i $KEY_FILE $LOGIN_NAME@$PUBLIC_ID
    return $?
}

# DoCleanup
#
# The STOP/TERMINATE flags may be "yes", "no" or "ask". If the resulting 
# state is "yes", then that action will done. Note that you can ask to
# "stop" and also "terminate" -- terminate is done after stop
#
DoCleanup() {
    local STOP_JSON STATE STATE_TO_CHECK MAX_ATTEMPTS ATTEMPT
    local DESCRIBE_INSTANCE_JSON 

    if [ "$TERMINATE_ON_SSH_EXIT" == "ask" ]; then
         ask TERMINATE_ON_SSH_EXIT "terminate           $INSTANCE_ID -- $NAME_TAG_INSTANCE ?" "(y/N) : " "no"
    fi
    if [ "$TERMINATE_ON_SSH_EXIT" != "yes" ]; then
        if [ "$STOP_ON_SSH_EXIT" == "ask" ]; then
             ask STOP_ON_SSH_EXIT   "stop                $INSTANCE_ID -- $NAME_TAG_INSTANCE ?" "(Y/n) : " "yes"
        fi
    else
        STOP_ON_SSH_EXIT=false       # don't need to stop if we are terminating 
    fi

        # perform the requested action

    if [ "$STOP_ON_SSH_EXIT" == "yes" ]; then
        printf "%-17s %21s -- %s\n" "stopping" "$INSTANCE_ID" "$NAME_TAG_INSTANCE"
        STOP_JSON=$(aws ec2 stop-instances --instance-ids  $INSTANCE_ID)
        STATE_TO_CHECK="stopped"
    fi
    if [ "$TERMINATE_ON_SSH_EXIT" == "yes" ]; then
        printf "%-17s %21s -- %s\n" "terminating" "$INSTANCE_ID" "$NAME_TAG_INSTANCE"
        TERMINATE_JSON=$(aws ec2 terminate-instances --instance-ids  $INSTANCE_ID)
        STATE_TO_CHECK="terminated"
    fi

        # spin waiting of instance to go to state if needed

    if [ "$STATE_TO_CHECK" == "" ]; then
        echo ""
        echo "To reconnect to $NAME_TAG_INSTANCE:"
        echo "    ssh -i $KEY_FILE $LOGIN_NAME@$PUBLIC_ID"
        echo ""
    else
            # wait till instance goes into requested state 

        MAX_ATTEMPTS=100
        for (( ATTEMPT=0; ATTEMPT<$MAX_ATTEMPTS; ATTEMPT++)); do
            DESCRIBE_INSTANCE_JSON=$(aws ec2 describe-instances --instance-id $INSTANCE_ID)
            STATE=$(echo $DESCRIBE_INSTANCE_JSON | jq .Reservations[0].Instances[0].State.Name | sed 's/\"//g')
            if [ "$STATE" == "$STATE_TO_CHECK" ]; then
                break
            fi
            printf "%3d %-9s %21s -- %s\r" $ATTEMPT "$STATE" "$INSTANCE_ID" "$NAME_TAG_INSTANCE"
            sleep 1
        done
        if [ "$STATE" != "$STATE_TO_CHECK" ]; then
            echo "Timeout, did not enter \"$STATE_TO_CHECK\" state       " >&2
            exit 1
        fi
        printf "%-17s %21s -- %s\n" "$STATE_TO_CHECK" "$INSTANCE_ID" "$NAME_TAG_INSTANCE"

        if [ "$TERMINATE_ON_SSH_EXIT" == "yes" ]; then
            if    [ "$SECURITY_GROUP_DELETE_IF_CREATED" == "true" ] \
               && [ "$SSH_SECURITY_GROUP_ID" != ""  ]; then
                echo Deleting security group $SSH_SECURITY_GROUP_ID \"$SSH_SECURITY_GROUP_NAME\"
                aws ec2 delete-security-group --group-id $SSH_SECURITY_GROUP_ID
            fi
        fi
           # just as a note here, code that set up the 2nd EBS volume set it's 'DeleteOnTermination'
           # flag, so it's not necessary to explicidly remove it when instance is terminated

        echo ""
    fi
}



# usage
#
# Prints usage command
#
usage() {
    echo "aws_last:  connects to or preforms other actions to last instance created"
    echo ""
    echo "usage:" 
    echo "   aws_last [options]"
    echo ""
    echo "Options:"
    echo "   state                    shows current state"
    echo "   stop                     stops instance if running"
    echo "   terminate                terminates instance if running"
    echo "   showssh                  displays ssh command needed"
    echo "   -h, help                 displays this help text"
    echo "   (no arguments)           starts if not running, ssh into it when ready"
    exit 1
}
# parse_args
#
# pulls in command line args and parses them into variables
# calls usage if any problem is found and exits
#
parse_args() {

    GetInstanceState              # this will exit if no instance data 
    if [ "$STATE" == "terminated" ]; then
        echo "The instance $INSTANCE_ID $NAME_TAG_INSTANCE is currently $STATE."
        return 1
    fi
    case "$1" in
        "state" )
            echo "The instance $INSTANCE_ID $NAME_TAG_INSTANCE is currently $STATE."
            return 0
            ;;
        "stop" )
            if [ "$STATE" == "running" ]; then
                TERMINATE_ON_SSH_EXIT="no" 
                STOP_ON_SSH_EXIT="yes"
                DoCleanup                # does all the work if the flag set right
            else 
                echo "The instance $INSTANCE_ID $NAME_TAG_INSTANCE is currently $STATE."
            fi
            return 0
            ;;
        "terminate" )
            TERMINATE_ON_SSH_EXIT="yes"
            DoCleanup
            return 0
            ;;
        "showssh" )
            GetInstanceIP                 # Queries IP address from the instance
            echo "ssh -i $KEY_FILE $LOGIN_NAME@$PUBLIC_ID"  
            return 0
            ;;
        "" )        
            GetInstanceState              # Query current state
            StartRunningIfNeeded          # start running if needed
            WaitForRunning                # wait till AWS reports instance is running
            GetInstanceIP                 # Queries IP address from the instance
            WaitForPing                   # waits till it can be pinged (requres Security rule)
            WaitForSSH                    # waits till instance responds to a ssh command
            DoSSH                         # opens up a SSH session on the running instance 
            RC=$?                         # exit code from process running in VM
            DoCleanup                     # shutdown/terminate/nothing depends on flags
            return $RC                    # return code from ssh session
            ;;
        *) 
            usage
            ;;
    esac 
}

#####################################################################
# Main
#
# See description at top of file.
#
# Parameters are passed through global enviornment variables This
# is not a recommended practice, but makes the example simpler
#
SourceStateFile               # source file containing InstanceID
CheckPrerequisites            # verify aws version, jq app exists
parse_args $@

exit $RC                      # return the VM exit code
